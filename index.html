<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gestor de Culto Ao Vivo</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- React e Babel -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Firebase -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, collection, getDocs, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        const firebaseConfig = {
            apiKey: "AIzaSyCYaOPtQdD1hU29awdgeN-rEGaoLGBGYBM",
            authDomain: "gestao-de-culto.firebaseapp.com",
            projectId: "gestao-de-culto",
            storageBucket: "gestao-de-culto.appspot.com",
            messagingSenderId: "843566675046",
            appId: "1:843566675046:web:cc1e54a813827f4502a9a7",
            measurementId: "G-LH68N60385"
        };

        const appId = typeof __app_id !== 'undefined' ? __app_id : 'worship-planner-default';

        try {
            const app = initializeApp(firebaseConfig);
            const db = getFirestore(app);
            const auth = getAuth(app);
            window.db = db;
            window.auth = auth;
            window.appId = appId;
            window.firestore = { doc, getDoc, setDoc, onSnapshot, collection, getDocs, deleteDoc };
            window.firebaseAuth = { signInAnonymously, signInWithCustomToken };
        } catch (e) {
            console.error("Erro ao inicializar o Firebase: ", e);
            alert("Não foi possível conectar ao Firebase. Verifique suas configurações e a conexão com a internet.");
        }
    </script>

    <style>
        body { font-family: 'Inter', sans-serif; }
        .font-mono { font-family: 'Roboto Mono', monospace; }
    </style>
</head>
<body>
    <div id="root">
        <div style="display: flex; justify-content: center; align-items: center; height: 100vh;">
            Carregando aplicativo...
        </div>
    </div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useMemo } = React;

        // --- ÍCONES EMBUTIDOS COMO COMPONENTES SVG ---
        const SvgIcon = ({ size = 24, className = '', children }) => (
          <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>{children}</svg>
        );
        const icons = {
          Plus: (props) => <SvgIcon {...props}><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></SvgIcon>,
          Play: (props) => <SvgIcon {...props}><polygon points="5 3 19 12 5 21 5 3"></polygon></SvgIcon>,
          Pause: (props) => <SvgIcon {...props}><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></SvgIcon>,
          Settings: (props) => <SvgIcon {...props}><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 0 2l-.15.08a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.38a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1 0-2l.15-.08a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"></path><circle cx="12" cy="12" r="3"></circle></SvgIcon>,
          Monitor: (props) => <SvgIcon {...props}><rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect><line x1="8" y1="21" x2="16" y2="21"></line><line x1="12" y1="17" x2="12" y2="21"></line></SvgIcon>,
          Server: (props) => <SvgIcon {...props}><rect x="2" y="2" width="20" height="8" rx="2" ry="2"></rect><rect x="2" y="14" width="20" height="8" rx="2" ry="2"></rect><line x1="6" y1="6" x2="6.01" y2="6"></line><line x1="6" y1="18" x2="6.01" y2="18"></line></SvgIcon>,
          ChevronUp: (props) => <SvgIcon {...props}><polyline points="18 15 12 9 6 15"></polyline></SvgIcon>,
          ChevronDown: (props) => <SvgIcon {...props}><polyline points="6 9 12 15 18 9"></polyline></SvgIcon>,
          Trash2: (props) => <SvgIcon {...props}><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></SvgIcon>,
          CheckCircle: (props) => <SvgIcon {...props}><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></SvgIcon>,
          RotateCcw: (props) => <SvgIcon {...props}><path d="M3 2v6h6"></path><path d="M3 13a9 9 0 1 0 3-7.7L3 8"></path></SvgIcon>,
          Clock: (props) => <SvgIcon {...props}><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></SvgIcon>,
          Upload: (props) => <SvgIcon {...props}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></SvgIcon>,
          Save: (props) => <SvgIcon {...props}><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></SvgIcon>,
          FolderOpen: (props) => <SvgIcon {...props}><path d="m6 14 1.45-2.9A2 2 0 0 1 9.24 10H20a2 2 0 0 1 2 2v4a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h3.9a2 2 0 0 1 1.69.9l.81 1.2a2 2 0 0 0 1.67.9H18a2 2 0 0 1 2 2v1"></path></SvgIcon>,
          Download: (props) => <SvgIcon {...props}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></SvgIcon>,
        };
        
        const AuthConfigurationError = () => (
            <div className="flex items-center justify-center min-h-screen bg-gray-100">
                <div className="max-w-2xl p-8 bg-white rounded-lg shadow-md text-center">
                    <h1 className="text-2xl font-bold text-red-600 mb-4">Erro de Configuração do Firebase</h1>
                    <p className="text-gray-700 mb-6">
                        O método de login "Anônimo" não está ativado no seu projeto Firebase. Para que o aplicativo funcione, você precisa ativá-lo.
                    </p>
                    <h2 className="text-lg font-semibold mb-3">Como Resolver:</h2>
                    <ol className="text-left space-y-2 list-decimal list-inside">
                        <li>Acesse o <a href="https://console.firebase.google.com/" target="_blank" rel="noopener noreferrer" className="text-blue-600 hover:underline">Console do Firebase</a> e abra seu projeto (`gestao-de-culto`).</li>
                        <li>No menu à esquerda, vá em **Build > Authentication**.</li>
                        <li>Clique na aba **Sign-in method**.</li>
                        <li>Na lista de provedores, encontre **Anônimo** e clique no ícone de lápis para editar.</li>
                        <li>Ative o botão e clique em **Salvar**.</li>
                    </ol>
                    <p className="mt-6 text-gray-600">
                        Após salvar, recarregue esta página.
                    </p>
                </div>
            </div>
        );

        const WorshipOrderControl = () => {
            const [currentPlan, setCurrentPlan] = useState({
                id: 'new-plan-' + Date.now(),
                name: `Novo Plano - ${new Date().toLocaleDateString('pt-BR')}`,
                items: [],
                cultInfo: {
                    date: new Date().toLocaleDateString('pt-BR', { day: '2-digit', month: 'long', year: 'numeric'}),
                    coordinator: 'Coordenador', leader: 'Dirigente', worship: 'Louvor', preacher: 'Pregador',
                    startTime: '19:00', liveTime: '19:30'
                }
            });
            const [liveState, setLiveState] = useState({ isLive: false, data: null });
            const [isLoading, setIsLoading] = useState(true);
            const [isSaving, setIsSaving] = useState(false);
            const [isAuthReady, setIsAuthReady] = useState(false);
            const [authError, setAuthError] = useState(null);
            const [role, setRole] = useState('coordinator');
            const [mode, setMode] = useState('planning');

            const db = window.db;
            const appId = window.appId;
            const firestore = window.firestore;
            const liveDocRef = db && firestore ? firestore.doc(db, "artifacts", appId, "public", "data", "worship-order", "live-state") : null;
            const plansCollectionRef = db && firestore ? firestore.collection(db, "artifacts", appId, "public", "data", "worship-plans") : null;

            useEffect(() => {
                const params = new URLSearchParams(window.location.search);
                if (params.get('view') === 'live') {
                    setRole('team');
                    setMode('presentation');
                }

                const { auth, firebaseAuth } = window;
                if (!auth || !firebaseAuth) { console.error("Firebase Auth não inicializado."); return; }
                const authenticate = async () => {
                    try {
                        if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                            await firebaseAuth.signInWithCustomToken(auth, __initial_auth_token);
                        } else {
                            await firebaseAuth.signInAnonymously(auth);
                        }
                        setIsAuthReady(true);
                    } catch (error) {
                        console.error("Erro de autenticação:", error);
                        setAuthError(error.code);
                        setIsLoading(false);
                    }
                };
                authenticate();
            }, []);
            
            useEffect(() => {
                if (!isAuthReady || !liveDocRef) return;
                const unsubscribe = firestore.onSnapshot(liveDocRef, (docSnap) => {
                    if (docSnap.exists()) {
                        setLiveState(docSnap.data());
                    }
                    setIsLoading(false);
                }, (error) => {
                    console.error("Erro no listener do Firebase: ", error);
                    setIsLoading(false);
                });
                return () => unsubscribe();
            }, [isAuthReady, liveDocRef]);

            const savePlan = async (planToSave) => {
                if (role !== 'coordinator') return;
                const planDocRef = firestore.doc(plansCollectionRef, planToSave.id);
                
                setIsSaving(true);
                try {
                    await firestore.setDoc(planDocRef, planToSave);
                    alert(`Plano "${planToSave.name}" salvo com sucesso!`);
                } catch (error) {
                    console.error("Erro ao salvar plano:", error);
                } finally {
                    setIsSaving(false);
                }
            };
            
            const goLive = async () => {
                if (role !== 'coordinator') return;
                if (confirm(`Tem certeza que deseja iniciar o plano "${currentPlan.name}"? Isso substituirá qualquer culto que esteja ao vivo.`)) {
                    const liveData = {
                        ...currentPlan,
                        liveState: {
                            currentItemIndex: 0,
                            isRunning: false,
                            currentTime: 0,
                            actualStartTime: null,
                        }
                    };
                    try {
                        await firestore.setDoc(liveDocRef, { isLive: true, data: liveData });
                        setMode('presentation');
                    } catch (e) {
                        console.error("Erro ao iniciar o culto:", e);
                    }
                }
            };

            const stopLive = async () => {
                if (role !== 'coordinator') return;
                 if (confirm("Tem certeza que deseja encerrar o culto ao vivo?")) {
                    try {
                        await firestore.setDoc(liveDocRef, { isLive: false, data: null });
                    } catch(e) {
                        console.error("Erro ao encerrar o culto:", e);
                    }
                 }
            };
            
            if (authError === 'auth/configuration-not-found') {
                return <AuthConfigurationError />;
            }
            
            if (isLoading) {
                return <div className="flex justify-center items-center h-screen bg-gray-100">Autenticando e Carregando...</div>;
            }

            return (
                <div className="min-h-screen bg-gray-100 p-4">
                    <div className="max-w-7xl mx-auto">
                        <div className="flex flex-wrap justify-between items-center mb-6 gap-4">
                            <h1 className="text-3xl font-bold text-gray-800">Gestor de Culto</h1>
                            {role === 'coordinator' && (
                                <div className="flex items-center gap-2">
                                    {isSaving && <div className="text-sm text-gray-500 flex items-center gap-1"><icons.Server size={14}/> Salvando...</div>}
                                    <button onClick={() => setMode(mode === 'planning' ? 'presentation' : 'planning')} className="bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded-md flex items-center gap-2">
                                        {mode === 'planning' ? <icons.Monitor size={18}/> : <icons.Settings size={18}/>}
                                        <span>{mode === 'planning' ? 'Ver Ao Vivo' : 'Planejamento'}</span>
                                    </button>
                                </div>
                            )}
                        </div>

                        {mode === 'planning' && role === 'coordinator' ? (
                            <PlanningView 
                                plan={currentPlan}
                                setPlan={setCurrentPlan}
                                onSave={savePlan}
                                onGoLive={goLive}
                                plansCollectionRef={plansCollectionRef}
                            />
                        ) : (
                            <PresentationView 
                                liveState={liveState}
                                onStopLive={stopLive}
                                role={role}
                                liveDocRef={liveDocRef}
                            />
                        )}
                    </div>
                </div>
            );
        };
        
        const InfoInput = ({ label, ...props }) => (
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">{label}</label>
              <input {...props} className="w-full border-gray-300 rounded-md shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm" />
            </div>
        );

        const PlanningView = ({ plan, setPlan, onSave, onGoLive, plansCollectionRef }) => {
            const fileInputRef = React.useRef(null);
            const [savedPlans, setSavedPlans] = useState([]);
            const [showLoadModal, setShowLoadModal] = useState(false);

            useEffect(() => {
                if (!showLoadModal) return;
                const fetchPlans = async () => {
                    if (!plansCollectionRef) return;
                    const querySnapshot = await window.firestore.getDocs(plansCollectionRef);
                    const plans = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    setSavedPlans(plans);
                };
                fetchPlans();
            }, [showLoadModal, plansCollectionRef]);
            
            const handleCultInfoChange = (field, value) => {
                setPlan(prev => ({...prev, cultInfo: {...prev.cultInfo, [field]: value}}));
            };

            const handleItemsChange = (newItems) => {
                setPlan(prev => ({...prev, items: newItems}));
            };

            const calculateStartTimes = (items, startTime) => {
                if (!startTime || !/^\d{2}:\d{2}$/.test(startTime)) {
                    return items.map(item => ({...item, startTime: '--:--'}));
                }
                let cumulativeTime = new Date(`1970-01-01T${startTime}:00`);
                if (isNaN(cumulativeTime)) return items.map(item => ({...item, startTime: '--:--'}));

                return items.map(item => {
                    const itemStartTime = cumulativeTime.toTimeString().slice(0, 5);
                    cumulativeTime.setMinutes(cumulativeTime.getMinutes() + (Number(item.duration) || 0));
                    return { ...item, startTime: itemStartTime };
                });
            };

            const handleSaveClick = () => {
                const planName = prompt("Digite um nome para este plano:", plan.name);
                if (planName) {
                    onSave({ ...plan, name: planName });
                }
            };
            
            const handleDownloadTemplate = () => {
                const headers = "Título;Duração;Tipo;Responsável;Descrição;Projeção;Som;Microfone;Iluminação;Câmera";
                const exampleRow = "Música Ambiente;25;música;Projeção + Som;Logo ambiente antes do culto;Logo;Liberar som PC;-;Ambiente;-";
                const csvContent = `${headers}\n${exampleRow}`;
                const blob = new Blob([`\uFEFF${csvContent}`], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement("a");
                const url = URL.createObjectURL(blob);
                link.setAttribute("href", url);
                link.setAttribute("download", "modelo_culto.csv");
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            };

            const handleFileImport = (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    const text = e.target.result;
                    try {
                        const rows = text.split('\n').filter(row => row.trim() !== '');
                        const headers = rows.shift().split(';').map(h => h.trim().toLowerCase());
                        
                        const requiredHeaders = ['título', 'duração', 'tipo', 'responsável'];
                        if (!requiredHeaders.every(h => headers.includes(h))) {
                            alert('Arquivo CSV inválido. Certifique-se de que a planilha contém as colunas: Título, Duração, Tipo, Responsável, etc.');
                            return;
                        }

                        const newItems = rows.map(row => {
                            const values = row.split(';');
                            const itemData = headers.reduce((obj, header, index) => {
                                obj[header] = values[index] ? values[index].trim() : '';
                                return obj;
                            }, {});

                            return {
                                id: Date.now() + Math.random(),
                                title: itemData['título'] || 'Sem Título',
                                duration: parseInt(itemData['duração'], 10) || 5,
                                type: itemData['tipo'] || 'palavra',
                                responsible: itemData['responsável'] || '',
                                description: itemData['descrição'] || '',
                                technical: {
                                    projection: itemData['projeção'] || '-',
                                    sound: itemData['som'] || '-',
                                    microphone: itemData['microfone'] || '-',
                                    lighting: itemData['iluminação'] || '-',
                                    camera: itemData['câmera'] || '-',
                                },
                                completed: false,
                                actualDuration: null,
                            };
                        });
                        
                        if (confirm(`Foram encontrados ${newItems.length} itens. Deseja substituir a ordem de culto atual?`)) {
                            handleItemsChange(calculateStartTimes(newItems, plan.cultInfo.startTime));
                        }

                    } catch (error) {
                        alert('Ocorreu um erro ao processar o arquivo. Verifique o formato do CSV.');
                        console.error("Erro ao importar CSV:", error);
                    }
                };
                reader.readAsText(file, 'UTF-8');
            };

            const addItem = () => {
                const newItem = {
                    id: Date.now(), title: 'Novo Momento', duration: 5, type: 'palavra', responsible: 'A definir', description: '',
                    technical: { projection: '-', sound: '-', microphone: '-', lighting: '-', camera: '-' },
                    completed: false, actualDuration: null,
                };
                handleItemsChange(calculateStartTimes([...plan.items, newItem], plan.cultInfo.startTime));
            };

            const updateItem = (id, updates) => {
                let newItems = plan.items.map(item => item.id === id ? { ...item, ...updates } : item);
                if (updates.duration !== undefined) {
                    newItems = calculateStartTimes(newItems, plan.cultInfo.startTime);
                }
                handleItemsChange(newItems);
            };
            
            const deleteItem = (id) => {
                if (confirm('Tem certeza que deseja excluir este item?')) {
                    handleItemsChange(calculateStartTimes(plan.items.filter(item => item.id !== id), plan.cultInfo.startTime));
                }
            };
            
            const moveItem = (index, direction) => {
                const currentItems = [...plan.items];
                const newIndex = index + direction;
                if (newIndex < 0 || newIndex >= currentItems.length) return;
                const item = currentItems.splice(index, 1)[0];
                currentItems.splice(newIndex, 0, item);
                handleItemsChange(calculateStartTimes(currentItems, plan.cultInfo.startTime));
            };

            return (
                <>
                    <div className="bg-white rounded-lg p-6 mb-6 shadow-sm">
                      <div className="flex justify-between items-center mb-4">
                        <h2 className="text-xl font-semibold">Informações do Culto: <span className="font-normal text-gray-600">{plan.name}</span></h2>
                        <div className="flex gap-2">
                            <button onClick={() => setShowLoadModal(true)} className="bg-yellow-500 hover:bg-yellow-600 text-white px-3 py-1 rounded-md flex items-center gap-2 text-sm"><icons.FolderOpen size={16}/> Carregar</button>
                            <button onClick={handleSaveClick} className="bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded-md flex items-center gap-2 text-sm"><icons.Save size={16}/> Salvar</button>
                        </div>
                      </div>
                      <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-4">
                          <InfoInput label="Data" value={plan.cultInfo.date} onChange={e => handleCultInfoChange('date', e.target.value)} />
                          <InfoInput label="Coordenador" value={plan.cultInfo.coordinator} onChange={e => handleCultInfoChange('coordinator', e.target.value)} />
                          <InfoInput label="Dirigente" value={plan.cultInfo.leader} onChange={e => handleCultInfoChange('leader', e.target.value)} />
                          <InfoInput label="Louvor" value={plan.cultInfo.worship} onChange={e => handleCultInfoChange('worship', e.target.value)} />
                          <InfoInput label="Pregador" value={plan.cultInfo.preacher} onChange={e => handleCultInfoChange('preacher', e.target.value)} />
                          <div className="flex gap-2">
                            <InfoInput label="Início" type="time" value={plan.cultInfo.startTime} onChange={e => handleCultInfoChange('startTime', e.target.value)} />
                            <InfoInput label="Live" type="time" value={plan.cultInfo.liveTime} onChange={e => handleCultInfoChange('liveTime', e.target.value)} />
                          </div>
                      </div>
                    </div>
                    <div className="bg-white rounded-lg shadow-sm">
                      <div className="p-4 border-b flex justify-between items-center">
                        <h2 className="text-xl font-semibold">Ordem de Culto</h2>
                        <div className="flex gap-2">
                           <input type="file" ref={fileInputRef} onChange={handleFileImport} className="hidden" accept=".csv"/>
                           <button onClick={handleDownloadTemplate} className="bg-gray-500 hover:bg-gray-600 text-white px-3 py-1 rounded-md flex items-center gap-2 text-sm"><icons.Download size={16}/> Modelo</button>
                           <button onClick={() => fileInputRef.current.click()} className="bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded-md flex items-center gap-2 text-sm"><icons.Upload size={16}/> Importar</button>
                           <button onClick={addItem} className="bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded-md flex items-center gap-2 text-sm"><icons.Plus size={16}/> Adicionar</button>
                           <button onClick={onGoLive} className="bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded-md flex items-center gap-2 text-sm font-bold"><icons.Play size={16}/> INICIAR CULTO</button>
                        </div>
                      </div>
                      <div className="divide-y divide-gray-200">
                        {plan.items.map((item, index) => (
                          <PlanningItem key={item.id} item={item} index={index} isFirst={index === 0} isLast={index === plan.items.length - 1} onUpdate={updateItem} onDelete={deleteItem} onMove={moveItem} />
                        ))}
                        {plan.items.length === 0 && <p className="p-4 text-gray-500">Nenhum item na ordem de culto. Adicione um para começar.</p>}
                      </div>
                    </div>
                    {showLoadModal && <LoadPlanModal plans={savedPlans} setPlan={setPlan} setShow={setShowLoadModal} plansCollectionRef={plansCollectionRef} />}
                </>
            );
        };

        const PlanningItem = ({ item, index, isFirst, isLast, onUpdate, onDelete, onMove }) => {
            const handleFieldChange = (field, value) => onUpdate(item.id, { [field]: value });
            const handleTechFieldChange = (field, value) => onUpdate(item.id, { technical: { ...item.technical, [field]: value } });
            const getTypeColor = type => ({'música': 'bg-blue-100 text-blue-800', 'oração': 'bg-purple-100 text-purple-800', 'palavra': 'bg-green-100 text-green-800', 'técnico': 'bg-orange-100 text-orange-800'})[type] || 'bg-gray-100 text-gray-800';
            
            return (
                <div className="p-4 hover:bg-gray-50">
                    <div className="flex items-start gap-3">
                        <div className="flex flex-col items-center pt-1">
                            <button onClick={() => onMove(index, -1)} disabled={isFirst} className="disabled:opacity-30"><icons.ChevronUp size={20} /></button>
                            <span className="font-mono text-lg font-bold text-gray-400">{index + 1}</span>
                            <button onClick={() => onMove(index, 1)} disabled={isLast} className="disabled:opacity-30"><icons.ChevronDown size={20} /></button>
                        </div>
                        <div className="flex-1">
                            <div className="grid grid-cols-1 md:grid-cols-5 gap-x-4 gap-y-2">
                                <input type="text" value={item.title} onChange={e => handleFieldChange('title', e.target.value)} placeholder="Título" className="md:col-span-2 border-gray-300 rounded-md shadow-sm text-lg font-semibold"/>
                                <input type="text" value={item.responsible} onChange={e => handleFieldChange('responsible', e.target.value)} placeholder="Responsável" className="border-gray-300 rounded-md shadow-sm"/>
                                <select value={item.type} onChange={e => handleFieldChange('type', e.target.value)} className={`border-gray-300 rounded-md shadow-sm font-medium ${getTypeColor(item.type)}`}>
                                    <option value="palavra">Palavra</option> <option value="música">Música</option> <option value="oração">Oração</option> <option value="técnico">Técnico</option>
                                </select>
                                <div className="flex items-center gap-2">
                                    <input type="number" value={item.duration} onChange={e => handleFieldChange('duration', parseInt(e.target.value, 10) || 0)} className="w-20 border-gray-300 rounded-md shadow-sm"/>
                                    <span className="text-gray-600">min</span>
                                    <span className="font-mono text-gray-800 bg-gray-100 px-2 py-1 rounded-md">{item.startTime}</span>
                                </div>
                            </div>
                            <textarea value={item.description} onChange={e => handleFieldChange('description', e.target.value)} placeholder="Descrição ou detalhes..." className="w-full mt-2 border-gray-300 rounded-md shadow-sm" rows="2"></textarea>
                        </div>
                        <div className="flex flex-col items-center pt-1">
                            <button onClick={() => onDelete(item.id)} className="text-red-500 hover:text-red-700 p-1"><icons.Trash2 size={18} /></button>
                        </div>
                    </div>
                </div>
            )
        };
        
        const LoadPlanModal = ({ plans, setPlan, setShow, plansCollectionRef }) => {
            const loadPlan = (plan) => {
                setPlan(plan);
                setShow(false);
            };
            const deletePlan = async (planId) => {
                if (confirm("Tem certeza que deseja apagar este plano? Esta ação não pode ser desfeita.")) {
                    const planDocRef = window.firestore.doc(plansCollectionRef, planId);
                    await window.firestore.deleteDoc(planDocRef);
                    setShow(false);
                }
            };
            return (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                    <div className="bg-white rounded-lg p-6 w-full max-w-md">
                        <h2 className="text-xl font-semibold mb-4">Carregar Plano Salvo</h2>
                        <div className="space-y-2 max-h-96 overflow-y-auto">
                            {plans.map(plan => (
                                <div key={plan.id} className="flex justify-between items-center p-2 border rounded-md">
                                    <span>{plan.name}</span>
                                    <div className="flex gap-2">
                                        <button onClick={() => loadPlan(plan)} className="bg-green-500 text-white px-3 py-1 text-sm rounded">Carregar</button>
                                        <button onClick={() => deletePlan(plan.id)} className="bg-red-500 text-white px-3 py-1 text-sm rounded"><icons.Trash2 size={16}/></button>
                                    </div>
                                </div>
                            ))}
                            {plans.length === 0 && <p className="text-gray-500">Nenhum plano salvo encontrado.</p>}
                        </div>
                        <button onClick={() => setShow(false)} className="mt-4 bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded w-full">Fechar</button>
                    </div>
                </div>
            )
        };

        const PresentationView = ({ liveState, onStopLive, role }) => {
            const db = window.db;
            const appId = window.appId;
            const firestore = window.firestore;
            const liveDocRef = db && firestore ? firestore.doc(db, "artifacts", appId, "public", "data", "worship-order", "live-state") : null;

            const handleUpdateLiveState = (newLiveStateData) => {
                if (role !== 'coordinator' || !liveDocRef) return;
                window.firestore.setDoc(liveDocRef, { isLive: true, data: newLiveStateData });
            };

            useEffect(() => {
                let interval;
                if (liveState.isLive && liveState.data?.liveState.isRunning && role === 'coordinator') {
                    interval = setInterval(() => {
                        const currentData = liveState.data;
                        const newLiveState = {
                            ...currentData.liveState,
                            currentTime: currentData.liveState.currentTime + 1
                        };
                        handleUpdateLiveState({ ...currentData, liveState: newLiveState });
                    }, 1000);
                }
                return () => clearInterval(interval);
            }, [liveState.isLive, liveState.data?.liveState.isRunning, liveState.data?.liveState.currentTime, role]);

            if (!liveState.isLive || !liveState.data) {
                return (
                    <div className="text-center p-10 bg-white rounded-lg shadow-md">
                        <h2 className="text-2xl font-bold">Aguardando o início do culto...</h2>
                        <p className="text-gray-600">A tela será atualizada automaticamente.</p>
                    </div>
                );
            }

            const { items, cultInfo, liveState: dataLiveState } = liveState.data;
            const { currentItemIndex, isRunning, currentTime, actualStartTime } = dataLiveState;
            const currentItem = items[currentItemIndex];

            const formatTime = (seconds) => {
                if (seconds < 0) seconds = 0;
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
            };

            const plannedDurationInSeconds = (currentItem?.duration || 0) * 60;
            const isOvertime = currentTime > plannedDurationInSeconds;
            const progressPercentage = plannedDurationInSeconds > 0 ? Math.min((currentTime / plannedDurationInSeconds) * 100, 100) : 0;
            
            const balance = useMemo(() => {
                let initialDelayInMinutes = 0;
                if (actualStartTime && cultInfo.startTime) {
                    const plannedStart = new Date(`1970-01-01T${cultInfo.startTime}:00`);
                    const actualStart = new Date(actualStartTime);
                    const actualStartOnSameDay = new Date(`1970-01-01T${actualStart.toTimeString().slice(0,8)}`);
                    if (!isNaN(plannedStart) && !isNaN(actualStartOnSameDay)) {
                        initialDelayInMinutes = (actualStartOnSameDay - plannedStart) / (1000 * 60);
                    }
                }
                const itemsBalance = items.slice(0, currentItemIndex).reduce((acc, item) => {
                    if (!item.completed) return acc;
                    const planned = item.duration || 0;
                    const actual = item.actualDuration != null ? item.actualDuration / 60 : planned;
                    return acc + (planned - actual);
                }, 0);
                return itemsBalance - initialDelayInMinutes;
            }, [items, currentItemIndex, actualStartTime, cultInfo.startTime]);

            const handleToggleTimer = () => {
                const newLiveState = { ...dataLiveState, isRunning: !isRunning };
                if (!isRunning && currentItemIndex === 0 && !actualStartTime) {
                    newLiveState.actualStartTime = new Date().toISOString();
                }
                handleUpdateLiveState({ ...liveState.data, liveState: newLiveState });
            };

            const handleResetTimer = () => {
                handleUpdateLiveState({ ...liveState.data, liveState: { ...dataLiveState, currentTime: 0 } });
            };

            const handleNext = () => {
                if (currentItemIndex >= items.length - 1) return;
                const newItems = items.map((item, index) => 
                    index === currentItemIndex ? { ...item, completed: true, actualDuration: currentTime } : item
                );
                handleUpdateLiveState({ 
                    ...liveState.data, 
                    items: newItems,
                    liveState: { ...dataLiveState, currentItemIndex: currentItemIndex + 1, currentTime: 0, isRunning: true }
                });
            };

            const handlePrevious = () => {
                if (currentItemIndex <= 0) return;
                handleUpdateLiveState({
                    ...liveState.data,
                    liveState: { ...dataLiveState, currentItemIndex: currentItemIndex - 1, currentTime: 0 }
                });
            };
            
            if (!currentItem) {
                return <div className="text-center p-10 bg-white rounded-lg shadow-md"><h2 className="text-2xl font-bold">Culto Finalizado</h2></div>
            }

            return (
                <div className="space-y-4">
                    <div className="bg-gray-800 text-white rounded-lg p-6 shadow-xl">
                        <div className="flex justify-between items-start">
                            <div>
                                <h2 className="text-3xl font-bold">{currentItem.title}</h2>
                                <p className="text-lg text-blue-300">{currentItem.responsible}</p>
                            </div>
                            <div className="text-right">
                                <div className="text-sm text-gray-400">Horário Previsto</div>
                                <div className="text-2xl font-mono">{currentItem.startTime}</div>
                            </div>
                        </div>
                        <div className="my-6 text-center">
                            <div className={`text-7xl font-mono ${isOvertime ? 'text-red-400' : 'text-green-400'}`}>{formatTime(currentTime)}</div>
                            <div className="text-gray-400">Planejado: {formatTime(plannedDurationInSeconds)}</div>
                        </div>
                        <div className="w-full bg-gray-700 rounded-full h-4 mb-6">
                            <div className={`h-4 rounded-full transition-all duration-500 ${isOvertime ? 'bg-red-500' : 'bg-green-500'}`} style={{ width: `${progressPercentage}%` }}/>
                        </div>
                        {role === 'coordinator' && (
                            <div className="flex justify-center gap-4">
                                <button onClick={handlePrevious} className="bg-gray-600 hover:bg-gray-500 px-4 py-2 rounded-lg disabled:opacity-50" disabled={currentItemIndex === 0}>Anterior</button>
                                <button onClick={handleToggleTimer} className={`px-6 py-2 rounded-lg flex items-center gap-2 text-lg ${isRunning ? 'bg-yellow-500' : 'bg-green-500'}`}>
                                    {isRunning ? <icons.Pause size={20}/> : <icons.Play size={20}/>}
                                    {isRunning ? 'Pausar' : 'Iniciar'}
                                </button>
                                <button onClick={handleResetTimer} className="bg-gray-600 hover:bg-gray-500 px-4 py-2 rounded-lg flex items-center gap-2"><icons.RotateCcw size={18}/> Reset</button>
                                <button onClick={handleNext} className="bg-blue-600 hover:bg-blue-500 px-4 py-2 rounded-lg disabled:opacity-50" disabled={currentItemIndex >= items.length - 1}>Próximo</button>
                                <button onClick={onStopLive} className="bg-red-600 hover:bg-red-700 px-4 py-2 rounded-lg">Encerrar</button>
                            </div>
                        )}
                    </div>
                    <div className="bg-gray-800 rounded-lg p-4">
                        <div className="flex justify-between items-center mb-3">
                            <h3 className="font-semibold text-white">Linha do Tempo</h3>
                            <div className={`text-sm font-semibold px-3 py-1 rounded-full ${balance >= 0 ? 'bg-green-200 text-green-800' : 'bg-red-200 text-red-800'}`}>
                                Balanço: {balance >= 0 ? '+' : ''}{Math.round(balance)} min
                            </div>
                        </div>
                        <div className="flex overflow-x-auto gap-3 pb-2">
                          {items.map((item, index) => (
                            <div key={item.id} className={`flex-shrink-0 w-48 p-3 rounded-lg border-2 transition-all ${index === currentItemIndex ? 'border-blue-500 bg-gray-700' : 'border-gray-600 bg-gray-700/50'}`}>
                              <div className="flex justify-between items-start">
                                <span className="text-xs font-mono text-gray-300">{item.startTime}</span>
                                {item.completed && <icons.CheckCircle size={16} className="text-green-400"/>}
                              </div>
                              <h4 className={`font-semibold text-sm mb-1 ${item.completed ? 'text-gray-400 line-through' : 'text-white'}`}>{item.title}</h4>
                              <div className="text-xs text-gray-400 flex items-center gap-1"><icons.Clock size={12} /> {item.duration} min</div>
                            </div>
                          ))}
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<WorshipOrderControl />);
    </script>
</body>
</html>
