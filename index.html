<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gestor de Culto Ao Vivo</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, collection, getDocs, addDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {
            apiKey: "SUA_API_KEY", 
            authDomain: "SEU_AUTH_DOMAIN",
            projectId: "SEU_PROJECT_ID",
            storageBucket: "SEU_STORAGE_BUCKET",
            messagingSenderId: "SEU_MESSAGING_SENDER_ID",
            appId: "SEU_APP_ID"
        };

        const appId = typeof __app_id !== 'undefined' ? __app_id : 'worship-planner-default';

        try {
            const app = initializeApp(firebaseConfig);
            const db = getFirestore(app);
            const auth = getAuth(app);
            window.db = db;
            window.auth = auth;
            window.appId = appId;
            window.firestore = { doc, getDoc, setDoc, onSnapshot, collection, getDocs, addDoc };
            window.firebaseAuth = { signInAnonymously, signInWithCustomToken };
        } catch (e) {
            console.error("Erro ao inicializar o Firebase: ", e);
            alert("Não foi possível conectar ao Firebase. Verifique suas configurações e a conexão com a internet.");
        }
    </script>

    <style>
        body { font-family: 'Inter', sans-serif; }
        .font-mono { font-family: 'Roboto Mono', monospace; }
        .hidden-file-input { display: none; }
    </style>
</head>
<body>
    <div id="root">
        <div style="display: flex; justify-content: center; align-items: center; height: 100vh;">
            Carregando aplicativo...
        </div>
    </div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useMemo, useRef } = React;

        const SvgIcon = ({ size = 24, className = '', children }) => (
          <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>{children}</svg>
        );
        const icons = {
          Plus: (props) => <SvgIcon {...props}><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></SvgIcon>,
          Play: (props) => <SvgIcon {...props}><polygon points="5 3 19 12 5 21 5 3"></polygon></SvgIcon>,
          Pause: (props) => <SvgIcon {...props}><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></SvgIcon>,
          Settings: (props) => <SvgIcon {...props}><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 0 2l-.15.08a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l-.22-.38a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1 0-2l.15-.08a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"></path><circle cx="12" cy="12" r="3"></circle></SvgIcon>,
          Monitor: (props) => <SvgIcon {...props}><rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect><line x1="8" y1="21" x2="16" y2="21"></line><line x1="12" y1="17" x2="12" y2="21"></line></SvgIcon>,
          Server: (props) => <SvgIcon {...props}><rect x="2" y="2" width="20" height="8" rx="2" ry="2"></rect><rect x="2" y="14" width="20" height="8" rx="2" ry="2"></rect><line x1="6" y1="6" x2="6.01" y2="6"></line><line x1="6" y1="18" x2="6.01" y2="18"></line></SvgIcon>,
          ChevronUp: (props) => <SvgIcon {...props}><polyline points="18 15 12 9 6 15"></polyline></SvgIcon>,
          ChevronDown: (props) => <SvgIcon {...props}><polyline points="6 9 12 15 18 9"></polyline></SvgIcon>,
          Trash2: (props) => <SvgIcon {...props}><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></SvgIcon>,
          CheckCircle: (props) => <SvgIcon {...props}><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></SvgIcon>,
          RotateCcw: (props) => <SvgIcon {...props}><path d="M3 2v6h6"></path><path d="M3 13a9 9 0 1 0 3-7.7L3 8"></path></SvgIcon>,
          Clock: (props) => <SvgIcon {...props}><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></SvgIcon>,
          UploadCloud: (props) => <SvgIcon {...props}><path d="M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.242"/><path d="M12 12v9"/><path d="m16 16-4-4-4 4"/></SvgIcon>,
          DownloadCloud: (props) => <SvgIcon {...props}><path d="M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.242"/><path d="M12 12v9"/><path d="m8 17 4 4 4-4"/></SvgIcon>,
          Save: (props) => <SvgIcon {...props}><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></SvgIcon>,
        };

        const WorshipOrderControl = () => {
            const [state, setState] = useState({
                items: [],
                cultInfo: {
                    date: new Date().toLocaleDateString('pt-BR', { day: '2-digit', month: 'long', year: 'numeric'}),
                    coordinator: 'Coordenador', leader: 'Dirigente', worship: 'Louvor', preacher: 'Pregador',
                    startTime: '19:00', liveTime: '19:30'
                },
                liveState: {
                    currentItemIndex: 0, isRunning: false, currentTime: 0, actualStartTime: null,
                }
            });
            const [isLoading, setIsLoading] = useState(true);
            const [isSaving, setIsSaving] = useState(false);
            const [isAuthReady, setIsAuthReady] = useState(false);
            const [mode, setMode] = useState('planning');
            const [showTechnical, setShowTechnical] = useState(true);
            const [presets, setPresets] = useState([]);
            const fileInputRef = useRef(null);

            const { db, appId, firestore } = window;
            
            const worshipDataBaseRef = useMemo(() => {
                if (!db || !firestore || !appId) return null;
                return firestore.doc(db, "artifacts", appId, "public", "data", "worship-order");
            }, [db, firestore, appId]);

            const liveDocRef = useMemo(() => {
                if (!worshipDataBaseRef) return null;
                return firestore.doc(worshipDataBaseRef, "state", "live");
            }, [worshipDataBaseRef, firestore]);

            const presetsCollectionRef = useMemo(() => {
                if (!worshipDataBaseRef) return null;
                return firestore.collection(worshipDataBaseRef, "presets");
            }, [worshipDataBaseRef, firestore]);

            useEffect(() => {
                const { auth, firebaseAuth } = window;
                if (!auth || !firebaseAuth) { 
                    console.error("Firebase Auth não inicializado."); 
                    setIsLoading(false); 
                    return; 
                }
                const authenticate = async () => {
                    try {
                        if (auth.currentUser) {
                            setIsAuthReady(true);
                            return;
                        }
                        if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                            await firebaseAuth.signInWithCustomToken(auth, __initial_auth_token);
                        } else {
                            await firebaseAuth.signInAnonymously(auth);
                        }
                        setIsAuthReady(true);
                    } catch (error) {
                        console.error("Erro de autenticação:", error);
                        setIsLoading(false);
                    }
                };
                authenticate();
            }, []);
            
            const saveStateToFirebase = useCallback(async (newState) => {
                if (!liveDocRef) return;
                setIsSaving(true);
                try {
                    const serializableState = JSON.parse(JSON.stringify(newState));
                    await firestore.setDoc(liveDocRef, serializableState, { merge: true });
                } catch (error) {
                    console.error("Erro ao salvar no Firebase:", error);
                } finally {
                    setTimeout(() => setIsSaving(false), 500);
                }
            }, [liveDocRef, firestore]);

            useEffect(() => {
                if (!isAuthReady) return;
                if (!liveDocRef) {
                    setIsLoading(false);
                    return;
                }
                const unsubscribe = firestore.onSnapshot(liveDocRef, (docSnap) => {
                    if (docSnap.exists()) {
                        setState(prevState => ({ ...prevState, ...docSnap.data() }));
                    } else {
                        saveStateToFirebase(state);
                    }
                    setIsLoading(false);
                }, (error) => {
                    console.error("Erro no listener do Firebase: ", error);
                    setIsLoading(false);
                });
                return () => unsubscribe();
            }, [isAuthReady, liveDocRef, state, saveStateToFirebase]);
            
            const fetchPresets = useCallback(async () => {
                if (!presetsCollectionRef) return;
                try {
                    const snapshot = await firestore.getDocs(presetsCollectionRef);
                    const presetsData = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    setPresets(presetsData);
                } catch (error) {
                    console.error("Erro ao carregar presets:", error);
                }
            }, [presetsCollectionRef, firestore]);

            useEffect(() => {
                if(isAuthReady) {
                    fetchPresets();
                }
            }, [isAuthReady, fetchPresets]);

            const handleStateUpdate = (newState) => {
                setState(newState);
                saveStateToFirebase(newState);
            };

            const calculateStartTimes = (items, startTime) => {
                if (!startTime || !/^\d{2}:\d{2}$/.test(startTime)) {
                    return items.map(item => ({...item, startTime: '--:--'}));
                }
                let cumulativeTime = new Date(`1970-01-01T${startTime}:00`);
                if (isNaN(cumulativeTime)) return items.map(item => ({...item, startTime: '--:--'}));

                return items.map(item => {
                    const itemStartTime = cumulativeTime.toTimeString().slice(0, 5);
                    cumulativeTime.setMinutes(cumulativeTime.getMinutes() + (Number(item.duration) || 0));
                    return { ...item, startTime: itemStartTime };
                });
            };

            const handleCultInfoChange = (field, value) => {
                const newCultInfo = { ...state.cultInfo, [field]: value };
                const newItems = calculateStartTimes(state.items, newCultInfo.startTime);
                handleStateUpdate({ ...state, cultInfo: newCultInfo, items: newItems });
            };

            const addItem = () => {
                const newItem = {
                    id: Date.now(), title: 'Novo Momento', duration: 5, type: 'palavra', responsible: 'A definir', description: '',
                    technical: { projection: '-', sound: '-', microphone: '-', lighting: '-', camera: '-' },
                    completed: false, actualDuration: null,
                };
                const newItems = calculateStartTimes([...state.items, newItem], state.cultInfo.startTime);
                handleStateUpdate({ ...state, items: newItems });
            };

            const updateItem = (id, updates) => {
                let newItems = state.items.map(item => item.id === id ? { ...item, ...updates } : item);
                if (updates.duration !== undefined) {
                    newItems = calculateStartTimes(newItems, state.cultInfo.startTime);
                }
                handleStateUpdate({ ...state, items: newItems });
            };
            
            const deleteItem = (id) => {
                if (confirm('Tem certeza que deseja excluir este item?')) {
                    const newItems = calculateStartTimes(state.items.filter(item => item.id !== id), state.cultInfo.startTime);
                    handleStateUpdate({ ...state, items: newItems });
                }
            };
            
            const moveItem = (index, direction) => {
                const currentItems = [...state.items];
                const newIndex = index + direction;
                if (newIndex < 0 || newIndex >= currentItems.length) return;
                const item = currentItems.splice(index, 1)[0];
                currentItems.splice(newIndex, 0, item);
                const newItems = calculateStartTimes(currentItems, state.cultInfo.startTime);
                handleStateUpdate({ ...state, items: newItems });
            };

            const handleSavePreset = async () => {
                const presetName = prompt("Digite um nome para este preset:", "Modelo de Culto Padrão");
                if (presetName && presetsCollectionRef) {
                    try {
                        const presetData = {
                            name: presetName,
                            savedAt: new Date().toISOString(),
                            items: state.items,
                            cultInfo: state.cultInfo,
                        };
                        await firestore.addDoc(presetsCollectionRef, presetData);
                        alert(`Preset "${presetName}" salvo com sucesso!`);
                        fetchPresets(); 
                    } catch (error) {
                        console.error("Erro ao salvar o preset:", error);
                        alert("Ocorreu um erro ao salvar o preset.");
                    }
                }
            };
            
            const handleLoadPreset = (presetId) => {
                if (!confirm("Isso substituirá a ordem de culto atual. Deseja continuar?")) return;
                const preset = presets.find(p => p.id === presetId);
                if (preset) {
                    const newItems = calculateStartTimes(preset.items, preset.cultInfo.startTime);
                    handleStateUpdate({
                        ...state,
                        items: newItems,
                        cultInfo: preset.cultInfo
                    });
                }
            };

            const handleDownloadTemplate = () => {
                const header = "title,duration,type,responsible,description\n";
                const example = "Música de Abertura,10,música,Ministério de Louvor,Usar playback e projeção com letra.\n";
                const csvContent = "data:text/csv;charset=utf-8," + encodeURIComponent(header + example);
                const link = document.createElement("a");
                link.setAttribute("href", csvContent);
                link.setAttribute("download", "modelo_ordem_de_culto.csv");
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            };

            const handleImportCSV = (event) => {
                const file = event.target.files[0];
                if (file) {
                    if (!confirm("Isso substituirá a ordem de culto atual com os dados do arquivo. Deseja continuar?")) {
                        event.target.value = null; 
                        return;
                    }
                    Papa.parse(file, {
                        header: true,
                        skipEmptyLines: true,
                        complete: (results) => {
                            const newItemsFromCSV = results.data.map(row => ({
                                id: Date.now() + Math.random(),
                                title: row.title || 'Sem Título',
                                duration: parseInt(row.duration, 10) || 5,
                                type: row.type || 'palavra',
                                responsible: row.responsible || 'A definir',
                                description: row.description || '',
                                technical: { projection: '-', sound: '-',
