<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gestor de Culto Ao Vivo</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- React e Babel -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Firebase -->
    <script type="module">
        // Importações necessárias do Firebase SDK
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, collection, getDocs, deleteDoc, updateDoc, serverTimestamp, query, where } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- INICIALIZAÇÃO SEGURA DO FIREBASE ---
        // Utiliza variáveis globais injetadas pelo ambiente para evitar expor configurações.
        // Isso é uma melhoria de segurança crucial em relação à versão anterior.
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'worship-planner-default';

        if (firebaseConfig) {
            try {
                const app = initializeApp(firebaseConfig);
                const db = getFirestore(app);
                const auth = getAuth(app);

                // Expondo as instâncias e funções do Firebase para o escopo global (window),
                // para que o script Babel possa acessá-las.
                window.db = db;
                window.auth = auth;
                window.appId = appId;
                
                // Agrupando funções do Firestore para fácil acesso
                window.firestore = { 
                    doc, getDoc, setDoc, onSnapshot, collection, 
                    getDocs, deleteDoc, updateDoc, serverTimestamp, query, where 
                };

                // Agrupando funções de autenticação
                window.firebaseAuth = { 
                    signInAnonymously, signInWithCustomToken, onAuthStateChanged 
                };

            } catch (e) {
                console.error("Erro ao inicializar o Firebase: ", e);
                // Exibe um erro se a inicialização falhar
                document.getElementById('root').innerHTML = `
                    <div class="flex items-center justify-center h-screen bg-red-100 text-red-800">
                        <div class="text-center p-8">
                            <h1 class="text-2xl font-bold">Falha na Conexão</h1>
                            <p>Não foi possível conectar ao Firebase. Verifique a configuração e sua conexão com a internet.</p>
                        </div>
                    </div>
                `;
            }
        } else {
             console.error("Configuração do Firebase não encontrada.");
             document.getElementById('root').innerHTML = `
                <div class="flex items-center justify-center h-screen bg-yellow-100 text-yellow-800">
                    <div class="text-center p-8">
                        <h1 class="text-2xl font-bold">Configuração Incompleta</h1>
                        <p>A configuração do Firebase não foi fornecida a este aplicativo.</p>
                    </div>
                </div>
            `;
        }
    </script>

    <style>
        body { font-family: 'Inter', sans-serif; }
        .font-mono { font-family: 'Roboto Mono', monospace; }
        /* Animação de carregamento */
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #09f;
            animation: spin 1s ease infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-100">
    <div id="root">
        <!-- Tela de carregamento inicial -->
        <div style="display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100vh;">
            <div class="spinner"></div>
            <p class="mt-4 text-gray-600">Carregando aplicativo...</p>
        </div>
    </div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useMemo, createContext, useContext } = React;

        // --- ÍCONES SVG ---
        // Componente genérico para ícones, promovendo reutilização.
        const SvgIcon = ({ size = 24, className = '', children }) => (
          <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>{children}</svg>
        );
        const icons = {
          Plus: (props) => <SvgIcon {...props}><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></SvgIcon>,
          Play: (props) => <SvgIcon {...props}><polygon points="5 3 19 12 5 21 5 3"></polygon></SvgIcon>,
          Pause: (props) => <SvgIcon {...props}><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></SvgIcon>,
          Settings: (props) => <SvgIcon {...props}><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 0 2l-.15.08a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.38a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1 0-2l.15-.08a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"></path><circle cx="12" cy="12" r="3"></circle></SvgIcon>,
          Monitor: (props) => <SvgIcon {...props}><rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect><line x1="8" y1="21" x2="16" y2="21"></line><line x1="12" y1="17" x2="12" y2="21"></line></SvgIcon>,
          ChevronUp: (props) => <SvgIcon {...props}><polyline points="18 15 12 9 6 15"></polyline></SvgIcon>,
          ChevronDown: (props) => <SvgIcon {...props}><polyline points="6 9 12 15 18 9"></polyline></SvgIcon>,
          Trash2: (props) => <SvgIcon {...props}><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></SvgIcon>,
          CheckCircle: (props) => <SvgIcon {...props}><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></SvgIcon>,
          RotateCcw: (props) => <SvgIcon {...props}><path d="M3 2v6h6"></path><path d="M3 13a9 9 0 1 0 3-7.7L3 8"></path></SvgIcon>,
          Clock: (props) => <SvgIcon {...props}><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></SvgIcon>,
          Save: (props) => <SvgIcon {...props}><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></SvgIcon>,
          FolderOpen: (props) => <SvgIcon {...props}><path d="m6 14 1.45-2.9A2 2 0 0 1 9.24 10H20a2 2 0 0 1 2 2v4a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h3.9a2 2 0 0 1 1.69.9l.81 1.2a2 2 0 0 0 1.67.9H18a2 2 0 0 1 2 2v1"></path></SvgIcon>,
          X: (props) => <SvgIcon {...props}><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></SvgIcon>,
          AlertTriangle: (props) => <SvgIcon {...props}><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></SvgIcon>,
        };
        
        // --- COMPONENTES DE UI REUTILIZÁVEIS ---

        // Componente de Spinner para indicar carregamento
        const Spinner = ({ text }) => (
            <div className="flex flex-col justify-center items-center h-full p-8">
                <div className="spinner"></div>
                {text && <p className="mt-4 text-gray-600">{text}</p>}
            </div>
        );

        // Componente de Modal genérico para substituir `alert` e `confirm`.
        // É acessível e estilizado com Tailwind.
        const Modal = ({ show, onClose, title, children, titleIcon }) => {
            if (!show) return null;

            return (
                <div className="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50" aria-modal="true" role="dialog">
                    <div className="bg-white rounded-lg p-6 w-full max-w-md shadow-2xl m-4">
                        <div className="flex justify-between items-center mb-4">
                            <div className="flex items-center gap-2">
                                {titleIcon}
                                <h2 className="text-xl font-semibold text-gray-800">{title}</h2>
                            </div>
                            <button onClick={onClose} className="text-gray-400 hover:text-gray-600">
                                <icons.X size={24} />
                            </button>
                        </div>
                        <div>{children}</div>
                    </div>
                </div>
            );
        };

        // --- COMPONENTES DE ERRO E ESTADO VAZIO ---

        // Tela exibida quando a autenticação anônima não está habilitada no Firebase.
        const AuthConfigurationError = () => (
            <div className="flex items-center justify-center min-h-screen bg-gray-100 p-4">
                <div className="max-w-2xl p-8 bg-white rounded-lg shadow-md text-center border-t-4 border-red-500">
                    <h1 className="text-2xl font-bold text-red-600 mb-4">Erro de Configuração do Firebase</h1>
                    <p className="text-gray-700 mb-6">
                        O método de login "Anônimo" não está ativado no seu projeto Firebase. Para que o aplicativo funcione, você precisa ativá-lo.
                    </p>
                    <h2 className="text-lg font-semibold mb-3">Como Resolver:</h2>
                    <ol className="text-left space-y-2 list-decimal list-inside bg-gray-50 p-4 rounded-md">
                        <li>Acesse o <a href="https://console.firebase.google.com/" target="_blank" rel="noopener noreferrer" className="text-blue-600 hover:underline font-semibold">Console do Firebase</a> e abra seu projeto.</li>
                        <li>No menu à esquerda, vá em <strong>Build > Authentication</strong>.</li>
                        <li>Clique na aba <strong>Sign-in method</strong>.</li>
                        <li>Na lista de provedores, encontre <strong>Anônimo</strong> e clique no ícone de lápis para editar.</li>
                        <li>Ative o botão e clique em <strong>Salvar</strong>.</li>
                    </ol>
                    <p className="mt-6 text-gray-600">
                        Após salvar, recarregue esta página.
                    </p>
                </div>
            </div>
        );

        // --- COMPONENTE PRINCIPAL DO APLICATIVO ---

        const App = () => {
            // Estados para controle de autenticação e carregamento
            const [isAuthReady, setIsAuthReady] = useState(false);
            const [authError, setAuthError] = useState(null);
            const [user, setUser] = useState(null);
            const [role, setRole] = useState('team'); // 'team' por padrão, 'coordinator' se tiver a permissão

            // Referências para as funções e objetos do Firebase no escopo global
            const { auth, firebaseAuth } = window;

            // Efeito para lidar com a autenticação na inicialização do app
            useEffect(() => {
                if (!auth || !firebaseAuth) {
                    console.error("Firebase Auth não inicializado.");
                    setAuthError('firebase-not-initialized');
                    return;
                }

                const authenticate = async () => {
                    try {
                        const authToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
                        if (authToken) {
                            await firebaseAuth.signInWithCustomToken(auth, authToken);
                        } else {
                            await firebaseAuth.signInAnonymously(auth);
                        }
                    } catch (error) {
                        console.error("Erro de autenticação:", error);
                        // Trata o erro específico de configuração não encontrada
                        if (error.code === 'auth/configuration-not-found') {
                            setAuthError(error.code);
                        } else {
                            setAuthError('generic-auth-error');
                        }
                    }
                };

                // Listener para mudanças no estado de autenticação
                const unsubscribe = firebaseAuth.onAuthStateChanged(auth, async (currentUser) => {
                    if (currentUser) {
                        setUser(currentUser);
                        // Aqui, em um app de produção, verificaríamos os custom claims do usuário
                        // para definir o 'role'. Para esta demo, simulamos isso.
                        // Ex: const idTokenResult = await currentUser.getIdTokenResult();
                        // setRole(idTokenResult.claims.role === 'coordinator' ? 'coordinator' : 'team');
                        
                        // Para esta demo, o papel é definido por um parâmetro de URL ou padrão.
                        const params = new URLSearchParams(window.location.search);
                        if (params.get('role') === 'coordinator') {
                           setRole('coordinator');
                        }
                    } else {
                        setUser(null);
                    }
                    setIsAuthReady(true);
                });
                
                authenticate();

                return () => unsubscribe();
            }, []);

            // Renderização condicional baseada no estado de autenticação
            if (authError === 'auth/configuration-not-found') {
                return <AuthConfigurationError />;
            }
            
            if (authError) {
                return <div className="flex justify-center items-center h-screen bg-red-100 text-red-700">Erro de autenticação. Verifique o console.</div>;
            }

            if (!isAuthReady || !user) {
                return <Spinner text="Autenticando..." />;
            }

            // Se autenticado, renderiza o gestor de culto
            return <WorshipOrderControl userRole={role} />;
        };

        // --- LÓGICA E COMPONENTES DO GESTOR DE CULTO ---

        const WorshipOrderControl = ({ userRole }) => {
            // Estado do plano de culto atual
            const [currentPlan, setCurrentPlan] = useState(null);
            // Estado do culto ao vivo, vindo do Firebase
            const [liveState, setLiveState] = useState({ isLive: false, data: null });
            // Estados de UI
            const [isLoading, setIsLoading] = useState(true);
            const [isSaving, setIsSaving] = useState(false);
            const [mode, setMode] = useState(userRole === 'coordinator' ? 'planning' : 'presentation');
            // Estado para controlar modais de confirmação
            const [confirmModal, setConfirmModal] = useState({ isOpen: false });

            // Referências do Firebase
            const { db, appId, firestore } = window;
            const liveDocRef = useMemo(() => db ? firestore.doc(db, "artifacts", appId, "public", "data", "worship-order", "live-state") : null, [db, appId]);
            const plansCollectionRef = useMemo(() => db ? firestore.collection(db, "artifacts", appId, "public", "data", "worship-plans") : null, [db, appId]);

            // Efeito para ouvir o estado 'ao vivo' do Firestore em tempo real
            useEffect(() => {
                if (!liveDocRef) return;
                const unsubscribe = firestore.onSnapshot(liveDocRef, (docSnap) => {
                    if (docSnap.exists()) {
                        setLiveState(docSnap.data());
                    } else {
                        setLiveState({ isLive: false, data: null });
                    }
                    setIsLoading(false);
                }, (error) => {
                    console.error("Erro no listener do Firebase: ", error);
                    setIsLoading(false);
                });
                return () => unsubscribe();
            }, [liveDocRef]);
            
            // Efeito para carregar o último plano salvo ou criar um novo
            useEffect(() => {
                const loadInitialPlan = async () => {
                    if (!plansCollectionRef) return;
                    // Lógica para carregar o último plano (simplificado para esta demo)
                    // Em um app real, poderia buscar o plano mais recente por data.
                    const newPlan = createNewPlan();
                    setCurrentPlan(calculateStartTimes(newPlan));
                };
                loadInitialPlan();
            }, []);
            
            // Função para criar um novo plano padrão
            const createNewPlan = () => ({
                id: 'new-plan-' + Date.now(),
                name: `Novo Plano - ${new Date().toLocaleDateString('pt-BR')}`,
                items: [],
                cultInfo: {
                    date: new Date().toISOString().split('T')[0],
                    coordinator: 'Coordenador', leader: 'Dirigente', worship: 'Louvor', preacher: 'Pregador',
                    startTime: '19:00', liveTime: '19:30'
                }
            });

            // Função para calcular os horários de início de cada item
            const calculateStartTimes = (plan) => {
                if (!plan || !plan.cultInfo.startTime || !/^\d{2}:\d{2}$/.test(plan.cultInfo.startTime)) {
                    return plan;
                }
                let cumulativeTime = new Date(`1970-01-01T${plan.cultInfo.startTime}:00`);
                if (isNaN(cumulativeTime)) return plan;

                const newItems = plan.items.map(item => {
                    const itemStartTime = cumulativeTime.toTimeString().slice(0, 5);
                    cumulativeTime.setMinutes(cumulativeTime.getMinutes() + (Number(item.duration) || 0));
                    return { ...item, startTime: itemStartTime };
                });
                return { ...plan, items: newItems };
            };

            // Manipulador para atualizar o plano
            const handlePlanUpdate = useCallback((updatedPlan) => {
                const recalculatedPlan = calculateStartTimes(updatedPlan);
                setCurrentPlan(recalculatedPlan);
            }, []);

            // Função para salvar o plano no Firestore
            const savePlan = async (planToSave) => {
                if (userRole !== 'coordinator' || !plansCollectionRef) return;
                const planDocRef = firestore.doc(plansCollectionRef, planToSave.id);
                
                setIsSaving(true);
                try {
                    await firestore.setDoc(planDocRef, { ...planToSave, savedAt: firestore.serverTimestamp() });
                    // Adicionar um toast de sucesso aqui seria ideal
                } catch (error) {
                    console.error("Erro ao salvar plano:", error);
                } finally {
                    setIsSaving(false);
                }
            };

            // Função para iniciar o modo 'ao vivo'
            const goLive = async () => {
                if (userRole !== 'coordinator') return;
                
                setConfirmModal({
                    isOpen: true,
                    title: "Iniciar Culto",
                    message: `Tem certeza que deseja iniciar o plano "${currentPlan.name}"? Isso substituirá qualquer culto que esteja ao vivo.`,
                    onConfirm: async () => {
                        const liveData = {
                            ...currentPlan,
                            liveState: {
                                currentItemIndex: 0,
                                isRunning: true,
                                currentTime: 0,
                                actualStartTime: new Date().toISOString(),
                                lastSyncTimestamp: firestore.serverTimestamp()
                            }
                        };
                        try {
                            await firestore.setDoc(liveDocRef, { isLive: true, data: liveData });
                            setMode('presentation');
                        } catch (e) {
                            console.error("Erro ao iniciar o culto:", e);
                        }
                    }
                });
            };

            // Função para parar o modo 'ao vivo'
            const stopLive = async () => {
                if (userRole !== 'coordinator') return;

                setConfirmModal({
                    isOpen: true,
                    title: "Encerrar Culto",
                    message: "Tem certeza que deseja encerrar o culto ao vivo?",
                    onConfirm: async () => {
                        try {
                            await firestore.setDoc(liveDocRef, { isLive: false, data: null });
                        } catch(e) {
                            console.error("Erro ao encerrar o culto:", e);
                        }
                    }
                });
            };
            
            if (isLoading || !currentPlan) {
                return <Spinner text="Carregando dados do culto..." />;
            }
            
            return (
                <div className="min-h-screen p-4 sm:p-6 lg:p-8">
                    <div className="max-w-7xl mx-auto">
                        <header className="flex flex-wrap justify-between items-center mb-6 gap-4">
                            <h1 className="text-3xl font-bold text-gray-800">Gestor de Culto Ao Vivo</h1>
                            {userRole === 'coordinator' && (
                                <div className="flex items-center gap-4">
                                    {isSaving && <div className="text-sm text-gray-500 flex items-center gap-1"><Spinner text={null}/> Salvando...</div>}
                                    <button 
                                        onClick={() => setMode(mode === 'planning' ? 'presentation' : 'planning')} 
                                        className="bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded-md flex items-center gap-2 transition-colors"
                                    >
                                        {mode === 'planning' ? <icons.Monitor size={18}/> : <icons.Settings size={18}/>}
                                        <span>{mode === 'planning' ? 'Ver Ao Vivo' : 'Planejamento'}</span>
                                    </button>
                                </div>
                            )}
                        </header>

                        <main>
                            {mode === 'planning' && userRole === 'coordinator' ? (
                                <PlanningView 
                                    plan={currentPlan}
                                    setPlan={handlePlanUpdate}
                                    onSave={savePlan}
                                    onGoLive={goLive}
                                    plansCollectionRef={plansCollectionRef}
                                />
                            ) : (
                                <PresentationView 
                                    liveState={liveState}
                                    onStopLive={stopLive}
                                    role={userRole}
                                />
                            )}
                        </main>
                    </div>
                    <Modal
                        show={confirmModal.isOpen}
                        onClose={() => setConfirmModal({ isOpen: false })}
                        title={confirmModal.title}
                        titleIcon={<icons.AlertTriangle className="text-yellow-500" />}
                    >
                        <p className="text-gray-600 mb-6">{confirmModal.message}</p>
                        <div className="flex justify-end gap-3">
                            <button onClick={() => setConfirmModal({ isOpen: false })} className="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300">Cancelar</button>
                            <button onClick={() => { confirmModal.onConfirm(); setConfirmModal({ isOpen: false }); }} className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">Confirmar</button>
                        </div>
                    </Modal>
                </div>
            );
        };
        
        // --- COMPONENTES DA VIEW DE PLANEJAMENTO ---

        const PlanningView = ({ plan, setPlan, onSave, onGoLive, plansCollectionRef }) => {
            const [showLoadModal, setShowLoadModal] = useState(false);

            const handleCultInfoChange = (field, value) => {
                setPlan(prev => ({...prev, cultInfo: {...prev.cultInfo, [field]: value}}));
            };

            const handleItemsChange = (newItems) => {
                setPlan(prev => ({...prev, items: newItems}));
            };
            
            const handleSaveClick = () => {
                onSave(plan);
            };

            const addItem = () => {
                const newItem = {
                    id: Date.now(), title: 'Novo Momento', duration: 5, type: 'palavra', responsible: 'A definir', description: ''
                };
                handleItemsChange([...plan.items, newItem]);
            };

            const updateItem = (id, updates) => {
                const newItems = plan.items.map(item => item.id === id ? { ...item, ...updates } : item);
                handleItemsChange(newItems);
            };
            
            const deleteItem = (id) => {
                handleItemsChange(plan.items.filter(item => item.id !== id));
            };
            
            const moveItem = (index, direction) => {
                const currentItems = [...plan.items];
                const newIndex = index + direction;
                if (newIndex < 0 || newIndex >= currentItems.length) return;
                const item = currentItems.splice(index, 1)[0];
                currentItems.splice(newIndex, 0, item);
                handleItemsChange(currentItems);
            };

            return (
                <>
                    <div className="bg-white rounded-lg p-6 mb-6 shadow-sm">
                        <div className="flex flex-wrap justify-between items-start mb-4 gap-4">
                            <h2 className="text-xl font-semibold text-gray-800">Informações do Culto</h2>
                            <div className="flex gap-2">
                                <button onClick={() => setShowLoadModal(true)} className="bg-yellow-500 hover:bg-yellow-600 text-white px-3 py-1 rounded-md flex items-center gap-2 text-sm"><icons.FolderOpen size={16}/> Carregar</button>
                                <button onClick={handleSaveClick} className="bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded-md flex items-center gap-2 text-sm"><icons.Save size={16}/> Salvar</button>
                            </div>
                        </div>
                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                            <InfoInput label="Nome do Plano" value={plan.name} onChange={e => setPlan(p => ({...p, name: e.target.value}))} />
                            <InfoInput label="Data" type="date" value={plan.cultInfo.date} onChange={e => handleCultInfoChange('date', e.target.value)} />
                            <InfoInput label="Coordenador" value={plan.cultInfo.coordinator} onChange={e => handleCultInfoChange('coordinator', e.target.value)} />
                            <InfoInput label="Dirigente" value={plan.cultInfo.leader} onChange={e => handleCultInfoChange('leader', e.target.value)} />
                            <InfoInput label="Louvor" value={plan.cultInfo.worship} onChange={e => handleCultInfoChange('worship', e.target.value)} />
                            <InfoInput label="Pregador" value={plan.cultInfo.preacher} onChange={e => handleCultInfoChange('preacher', e.target.value)} />
                            <div className="flex gap-2">
                                <InfoInput label="Início" type="time" value={plan.cultInfo.startTime} onChange={e => handleCultInfoChange('startTime', e.target.value)} />
                                <InfoInput label="Live" type="time" value={plan.cultInfo.liveTime} onChange={e => handleCultInfoChange('liveTime', e.target.value)} />
                            </div>
                        </div>
                    </div>
                    <div className="bg-white rounded-lg shadow-sm">
                        <div className="p-4 border-b flex flex-wrap justify-between items-center gap-4">
                            <h2 className="text-xl font-semibold text-gray-800">Ordem de Culto</h2>
                            <div className="flex gap-2">
                                <button onClick={addItem} className="bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded-md flex items-center gap-2 text-sm"><icons.Plus size={16}/> Adicionar</button>
                                <button onClick={onGoLive} className="bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded-md flex items-center gap-2 text-sm font-bold"><icons.Play size={16}/> INICIAR CULTO</button>
                            </div>
                        </div>
                        <div className="divide-y divide-gray-200">
                            {plan.items.map((item, index) => (
                                <PlanningItem key={item.id} item={item} index={index} isFirst={index === 0} isLast={index === plan.items.length - 1} onUpdate={updateItem} onDelete={deleteItem} onMove={moveItem} />
                            ))}
                            {plan.items.length === 0 && <p className="p-4 text-gray-500 text-center">Nenhum item na ordem de culto. Adicione um para começar.</p>}
                        </div>
                    </div>
                    <LoadPlanModal 
                        show={showLoadModal} 
                        onClose={() => setShowLoadModal(false)}
                        onLoad={setPlan} 
                        plansCollectionRef={plansCollectionRef} 
                    />
                </>
            );
        };

        const InfoInput = ({ label, ...props }) => (
            <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">{label}</label>
                <input {...props} className="w-full border-gray-300 rounded-md shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm" />
            </div>
        );

        const PlanningItem = ({ item, index, isFirst, isLast, onUpdate, onDelete, onMove }) => {
            const getTypeColor = type => ({'música': 'bg-blue-100 text-blue-800', 'oração': 'bg-purple-100 text-purple-800', 'palavra': 'bg-green-100 text-green-800', 'técnico': 'bg-orange-100 text-orange-800'})[type] || 'bg-gray-100 text-gray-800';
            
            return (
                <div className="p-4 hover:bg-gray-50 transition-colors">
                    <div className="flex items-start gap-3">
                        <div className="flex flex-col items-center pt-1">
                            <button onClick={() => onMove(index, -1)} disabled={isFirst} className="disabled:opacity-30 disabled:cursor-not-allowed text-gray-500 hover:text-gray-800"><icons.ChevronUp size={20} /></button>
                            <span className="font-mono text-lg font-bold text-gray-400 select-none">{String(index + 1).padStart(2, '0')}</span>
                            <button onClick={() => onMove(index, 1)} disabled={isLast} className="disabled:opacity-30 disabled:cursor-not-allowed text-gray-500 hover:text-gray-800"><icons.ChevronDown size={20} /></button>
                        </div>
                        <div className="flex-1">
                            <div className="grid grid-cols-1 md:grid-cols-5 gap-x-4 gap-y-2">
                                <input type="text" value={item.title} onChange={e => onUpdate(item.id, { title: e.target.value })} placeholder="Título" className="md:col-span-2 border-gray-300 rounded-md shadow-sm text-lg font-semibold"/>
                                <input type="text" value={item.responsible} onChange={e => onUpdate(item.id, { responsible: e.target.value })} placeholder="Responsável" className="border-gray-300 rounded-md shadow-sm"/>
                                <select value={item.type} onChange={e => onUpdate(item.id, { type: e.target.value })} className={`border-gray-300 rounded-md shadow-sm font-medium ${getTypeColor(item.type)}`}>
                                    <option value="palavra">Palavra</option> <option value="música">Música</option> <option value="oração">Oração</option> <option value="técnico">Técnico</option>
                                </select>
                                <div className="flex items-center gap-2">
                                    <input type="number" value={item.duration} onChange={e => onUpdate(item.id, { duration: parseInt(e.target.value, 10) || 0 })} className="w-20 border-gray-300 rounded-md shadow-sm"/>
                                    <span className="text-gray-600">min</span>
                                    <span className="font-mono text-gray-800 bg-gray-100 px-2 py-1 rounded-md">{item.startTime || '--:--'}</span>
                                </div>
                            </div>
                            <textarea value={item.description} onChange={e => onUpdate(item.id, { description: e.target.value })} placeholder="Descrição ou detalhes..." className="w-full mt-2 border-gray-300 rounded-md shadow-sm" rows="2"></textarea>
                        </div>
                        <div className="flex flex-col items-center pt-1">
                            <button onClick={() => onDelete(item.id)} className="text-red-500 hover:text-red-700 p-1"><icons.Trash2 size={18} /></button>
                        </div>
                    </div>
                </div>
            )
        };
        
        const LoadPlanModal = ({ show, onClose, onLoad, plansCollectionRef }) => {
            const [savedPlans, setSavedPlans] = useState([]);
            const [isLoading, setIsLoading] = useState(true);
            const { firestore } = window;

            useEffect(() => {
                if (!show || !plansCollectionRef) return;
                const fetchPlans = async () => {
                    setIsLoading(true);
                    try {
                        const querySnapshot = await firestore.getDocs(plansCollectionRef);
                        const plans = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                        setSavedPlans(plans);
                    } catch (error) {
                        console.error("Erro ao buscar planos:", error);
                    } finally {
                        setIsLoading(false);
                    }
                };
                fetchPlans();
            }, [show, plansCollectionRef]);

            return (
                <Modal show={show} onClose={onClose} title="Carregar Plano Salvo" titleIcon={<icons.FolderOpen className="text-yellow-500" />}>
                    <div className="space-y-2 max-h-96 overflow-y-auto">
                        {isLoading ? <Spinner text="Buscando planos..." /> : (
                            <>
                                {savedPlans.map(plan => (
                                    <div key={plan.id} className="flex justify-between items-center p-2 border rounded-md hover:bg-gray-50">
                                        <span>{plan.name}</span>
                                        <button onClick={() => { onLoad(plan); onClose(); }} className="bg-green-500 text-white px-3 py-1 text-sm rounded hover:bg-green-600">Carregar</button>
                                    </div>
                                ))}
                                {savedPlans.length === 0 && <p className="text-gray-500">Nenhum plano salvo encontrado.</p>}
                            </>
                        )}
                    </div>
                    <button onClick={onClose} className="mt-4 bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded w-full">Fechar</button>
                </Modal>
            );
        };
        
        // --- COMPONENTES DA VIEW DE APRESENTAÇÃO ---

        const PresentationView = ({ liveState, onStopLive, role }) => {
            if (!liveState.isLive || !liveState.data) {
                return (
                    <div className="text-center p-10 bg-white rounded-lg shadow-md">
                        <h2 className="text-2xl font-bold text-gray-800">Aguardando o início do culto...</h2>
                        <p className="text-gray-600 mt-2">A tela será atualizada automaticamente.</p>
                    </div>
                );
            }
            
            const { items, cultInfo, liveState: dataLiveState } = liveState.data;
            const { currentItemIndex } = dataLiveState;
            const currentItem = items[currentItemIndex];

            if (!currentItem) {
                return (
                    <div className="text-center p-10 bg-white rounded-lg shadow-md">
                        <h2 className="text-2xl font-bold text-green-700">Culto Finalizado</h2>
                        {role === 'coordinator' && (
                            <button onClick={onStopLive} className="mt-4 bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded-lg">Encerrar e Voltar ao Planejamento</button>
                        )}
                    </div>
                );
            }

            return (
                <div className="space-y-4">
                    <LiveControlPanel liveState={liveState} onStopLive={onStopLive} role={role} />
                    <Timeline items={items} currentItemIndex={currentItemIndex} />
                </div>
            );
        };
        
        const LiveControlPanel = ({ liveState, onStopLive, role }) => {
            const [displayTime, setDisplayTime] = useState(0);
            const { updateDoc, serverTimestamp } = window.firestore;
            const liveDocRef = window.db ? window.firestore.doc(window.db, "artifacts", window.appId, "public", "data", "worship-order", "live-state") : null;

            const { items, liveState: dataLiveState } = liveState.data;
            const { currentItemIndex, isRunning, currentTime, lastSyncTimestamp } = dataLiveState;
            const currentItem = items[currentItemIndex];

            useEffect(() => {
                let interval;
                if (isRunning) {
                    const lastSync = lastSyncTimestamp?.toDate()?.getTime() || Date.now();
                    interval = setInterval(() => {
                        const elapsedSeconds = Math.floor((Date.now() - lastSync) / 1000);
                        setDisplayTime(currentTime + elapsedSeconds);
                    }, 250);
                } else {
                    setDisplayTime(currentTime || 0);
                }
                return () => clearInterval(interval);
            }, [isRunning, currentTime, lastSyncTimestamp]);

            const formatTime = (seconds) => {
                if (seconds < 0) seconds = 0;
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
            };

            const plannedDurationInSeconds = (currentItem?.duration || 0) * 60;
            const isOvertime = displayTime > plannedDurationInSeconds;
            const progressPercentage = plannedDurationInSeconds > 0 ? Math.min((displayTime / plannedDurationInSeconds) * 100, 100) : 0;

            const handleLiveUpdate = (updates) => {
                if (role !== 'coordinator' || !liveDocRef) return;
                const payload = {};
                for (const key in updates) {
                    payload[`data.liveState.${key}`] = updates[key];
                }
                updateDoc(liveDocRef, payload);
            };

            const handleFullDataUpdate = (newLiveData) => {
                if (role !== 'coordinator' || !liveDocRef) return;
                window.firestore.setDoc(liveDocRef, { isLive: true, data: newLiveData });
            };

            const handleToggleTimer = () => {
                handleLiveUpdate({ isRunning: !isRunning, currentTime: displayTime, lastSyncTimestamp: serverTimestamp() });
            };

            const handleNext = () => {
                if (currentItemIndex >= items.length - 1) return;
                const newItems = items.map((item, index) => 
                    index === currentItemIndex ? { ...item, completed: true, actualDuration: displayTime } : item
                );
                handleFullDataUpdate({ 
                    ...liveState.data, 
                    items: newItems,
                    liveState: { ...dataLiveState, currentItemIndex: currentItemIndex + 1, currentTime: 0, isRunning: true, lastSyncTimestamp: serverTimestamp() }
                });
            };

            return (
                <div className="bg-gray-800 text-white rounded-lg p-6 shadow-xl">
                    <div className="flex justify-between items-start">
                        <div>
                            <h2 className="text-3xl font-bold">{currentItem.title}</h2>
                            <p className="text-lg text-blue-300">{currentItem.responsible}</p>
                        </div>
                        <div className="text-right">
                            <div className="text-sm text-gray-400">Previsto</div>
                            <div className="text-2xl font-mono">{currentItem.startTime}</div>
                        </div>
                    </div>
                    <div className="my-6 text-center">
                        <div className={`text-7xl font-mono ${isOvertime ? 'text-red-400' : 'text-green-400'}`}>{formatTime(displayTime)}</div>
                        <div className="text-gray-400">Planejado: {formatTime(plannedDurationInSeconds)}</div>
                    </div>
                    <div className="w-full bg-gray-700 rounded-full h-4 mb-6">
                        <div className={`h-4 rounded-full transition-all duration-500 ${isOvertime ? 'bg-red-500' : 'bg-green-500'}`} style={{ width: `${progressPercentage}%` }}/>
                    </div>
                    {role === 'coordinator' && (
                        <div className="flex flex-wrap justify-center gap-4">
                            <button onClick={handleToggleTimer} className={`px-6 py-2 rounded-lg flex items-center gap-2 text-lg ${isRunning ? 'bg-yellow-500' : 'bg-green-500'}`}>
                                {isRunning ? <icons.Pause size={20}/> : <icons.Play size={20}/>}
                                {isRunning ? 'Pausar' : 'Iniciar'}
                            </button>
                            <button onClick={handleNext} className="bg-blue-600 hover:bg-blue-500 px-4 py-2 rounded-lg disabled:opacity-50" disabled={currentItemIndex >= items.length - 1}>Próximo</button>
                            <button onClick={onStopLive} className="bg-red-600 hover:bg-red-700 px-4 py-2 rounded-lg">Encerrar</button>
                        </div>
                    )}
                </div>
            );
        };

        const Timeline = ({ items, currentItemIndex }) => (
            <div className="bg-gray-800 rounded-lg p-4">
                <h3 className="font-semibold text-white mb-3">Linha do Tempo</h3>
                <div className="flex overflow-x-auto gap-3 pb-2">
                  {items.map((item, index) => (
                    <div key={item.id} className={`flex-shrink-0 w-48 p-3 rounded-lg border-2 transition-all ${index === currentItemIndex ? 'border-blue-500 bg-gray-700' : 'border-gray-600 bg-gray-700/50'}`}>
                        <div className="flex justify-between items-start">
                            <span className="text-xs font-mono text-gray-300">{item.startTime}</span>
                            {item.completed && <icons.CheckCircle size={16} className="text-green-400"/>}
                        </div>
                        <h4 className={`font-semibold text-sm mb-1 ${item.completed ? 'text-gray-400 line-through' : 'text-white'}`}>{item.title}</h4>
                        <div className="text-xs text-gray-400 flex items-center gap-1"><icons.Clock size={12} /> {item.duration} min</div>
                    </div>
                  ))}
                </div>
            </div>
        );

        // --- RENDERIZAÇÃO DO APLICATIVO ---
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
